# Creational Design Pattern
This pattern control object creation by defining ***how*, *where* and *how* many objects should be created**.

*Creational design patterns define how an object is created, where the creation logic resides, and how many instances of an object should be created.*
| Pattern | How Object is Created | Where Creation Logic Lives | How Many Objects |
|-------|----------------------|----------------------------|------------------|
| **Singleton** | Controlled instance creation | Inside the class itself | Only one instance |
| **Factory Method** | Via a factory method | Factory class or method | Multiple instances |
| **Abstract Factory** | Via a group of factories | Factory family | Multiple related instances |
| **Builder** | Step-by-step construction | Builder class | One complex object |
| **Prototype** | By cloning an existing object | Existing object | Multiple cloned instances |


---
# 1. Singleton
Singleton is a creational design pattern that ensures a **class has only one instance/object** and provides a **global access point** to that instance/object.

### When to use
- Singleton is best used for stateless(does not store changing data) or immutable shared services like loggers or configuration managers (services common for all). Using Singleton to store mutable business state introduces global state, concurrency issues, and makes the system hard to test and scale.
- Configuration manager
- Logger
- Cache
- Thread pool
- Application-wide settings

### How to implement ?
- Private constructor
- Static instance reference
- Public method to access the instance
- Instance is created **once**

### Spring Boot Perspective
- Bean is singleton by default
- Service is stateless
- Business data passed as method arguments
- Classes annotated with **@Service, @Controller, @Repository, or @Component are singleton by default**. This means only one instance exists in the application context.

### Guidelines:
- Do NOT use mutable global variables in singleton services
- Pass data through method parameters instead
- Keep services stateless to ensure thread safety and scalability

### Implementation
*Lets create Database as singleton class*

```java
class Database{
  public Database(){}  // wrong
 //If a class has public constructor that class can never become singleton becuase constructor always creates new object and return old one.

  private Database(){} // right Now no one can create object using constructor.
}
``` 

Now, Question is how an object will be created ?
ans :  we can create a method `getInstance()`,which will create an object of Database.

```java
class Database{
  private Database(){} 
  public Database getInstance(){
    return new Database();
  }
}
```

But again, Above approach gives access to other classes to create multiple objects of Database and we do not want that. what should be done next ?
ans : we can create an instance variable which would help us to check for the instance created or not.
```java
class Database{
  private Database instance = null;
  private Database(){} 
  public Database getInstance(){
    if(instance == null){
      instance = new Database();
    }
  return instance;
  }
}
```

Would other classes be able to call `getInstance()` method without creating an object of Database ?
ans : No, here come `static` in picture, we can make `getInstance()` as static method and since A static method can only directly access static variables. we need to make `instance` variable also static.
```java
class Database{
  private static Database instance = null;
  private Database(){} 
  public static Database getInstance(){
    if(instance == null){
      instance = new Database();
    }
  return instance;
  }
}
```







